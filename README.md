# 비동기 통신 웹 구현
로그인, 유저 관리, 문의 게시판 등의 기능을 비동기 통신을 통해 구현하는 실습

2021년 12월 20일 작업 내용:
- 로그인 창 마크업 완료
- 회원가입 창 마크업 완료
- 회원가입 입력값 유효성 검사 기능 구현

2021년 12월 21일 작업 내용:
- 회원가입 정보 로컬 스토리지 입력 기능 구현
- 유저 아이디 중복 검사 기능 추가
- 로그인 유효성 검사 기능 구현
- css 수정

2021년 12월 22일 작업 내용:
- 로그인, 회원가입, 회원정보 수정 및 삭제 API 요청
- 공지사항 게시판 마크업 추가
- 공지사항 게시판 목록 기능 구현 (pagination 제외)
- 공지사항 게시판 내용 기능 일부 구현

2021년 12월 23일 작업 내용:
- 공지사항 게시글 목록 기능 오류 수정 : id값을 동일한 값만 파라미터로 넘기는 오류 수정
- 공지사항 게시판 내용 보기 기능 구현 완료
- 공지사항 게시판 글쓰기 기능 일부 구현 : API를 이용한 통신은 API가 개발완료된 후 할 예정
- 회원 정보 퍼블리싱 일부 구현

2021년 12월 24일, 27일 작업 내용:
- 공지사항 게시글 리스트 데이터 구현시 깜빡임을 방지하기 위해 미리 리스트를 마크업 해두고 그 안에 데이터를 넣는 방식으로 변경(이전에는 마크업과 함께 데이터를 함께 띄움)
- 등록된 공지사항이 없을 경우 등록된 공지사항이 없다는 화면이 나오도록 구현
- 게시글 내용 css 일부 수정
- 동기, 비동기의 정확한 차이 학습

2021년 12월 28일 작업 내용 :
- 회원정보 데이터 호출 기능 구현
- 회원정보 비밀번호 변경, 회원탈퇴 비동기 통신 기능 구현 (API 적용 X)
- 회원정보창을 URL로 들어올 경우 로그인 세션이 없으면 로그인 창으로 가도록 적용
- 로그인창을 URL로 들어올 경우 세션 삭제
- 회원정보 비밀번호 변경 모달창 구현 

------------

## 추가 및 수정 계획
- 

------------
## 새로 알게 된 내용
1. fetch()
- fetch()가 리턴하는 Promise 객체는 HTTP error 상태를 reject하지 않는다. 대신 ok 상태가 false인 resolve가 반환된다.
- 네트워크 장애나 요청이 완료되지 못한 상태에는 reject가 반환된다.
- fetch api를 사용하기 위해서는 실제 포트 위에 띄워놓아야 한다. -> 로컬에서 html 파일을 브라우저로 실행 시켰을 때 실행 불가능
- 응답 단계
    1. 서버에서 응답 헤더를 받자마자 fetch 호출 시 반환받은 promise가 내장 클래스 Response의 인스턴스와 함께 이행 상태가 된다.
    2. 아직 body가 도착하기 전이지만, 응답 헤더를 보고 요청이 성공적으로 처리되었는지 아닌지 확인 가능
    3. text(), json(), formData(), blob(), arrayBuffer() 등의 프로미스 기반 메소드를 이용해 body를 처리할 수 있다.

2. CORS
- Cross-Origin Resource Sharing
- 다른 출처간에 리소스를 공유할 수 있도록 하는 것
- 백엔드에서 요청을 허락할 다른 출처들을 명시함으로서 해결 가능
- 크롬 브라우저에서는 매우 엄격히 SOP를 지키기 때문에 로컬 파일에 접근할 때 Origin이 반드시 null로 나타난다.

3. SOP
- Same Origin Policy
- 대부분의 웹 브라우저가 준수하는 보안 정책
- 다른 Origin에 요청한 것을 기본적으로 제한해서 어느정도 해커의 공격을 방어하는 것

4. HTTPS Status Code
- 200 : OK, 정상적으로 처리됐을 경우 발생
- 201 : Created, 정상적으로 처리되었고 새로운 리소스가 생겼을 경우 발생
- 202 : Accepted, 요청은 정상적이지만, 서버가 아직 요청을 완료하지 못한 경우 발생
- 204 : No Content, 요청은 정상적이지만, 컨텐츠를 제공하지 않는 경우 발생
- 400 : Bad Request요청이 유효하지 않아 더 이상 작업을 진행하지 않는 경우 발생
- 401 : Unauthorized, 인증이 안되어 있을 경우 발생
- 403 : Forbidden, 권한이 없을 경우 발생
- 404 : Not Found, 경로나 자원이 존재하지 않을 경우 발생
- 405 : Method Not Allowed, 허용되지 않는 메소드가 사용된 경우 발생
- 409 : Conflict, 해당 요청의 처리 중 비지니스 로직상 불가능하거나 모순이 생긴 경우 발생
- 429 : Too Many Requests, 클라이언트가 일정 시간 동안 너무 많은 요청을 보낸 경우, 비정상적인 방법으로 자원을 요청하는 경우 발생
- 500 : Server errors, 서버 오류로 인해 발생

6. 사용자 인증
- Authentication
    - 로그인, 즉 특정 서비스에 일정 권한이 주어진 사용자임을 아이디와 패스워드 등을 통해서 인증 받는 것
- Authorization
    - 한 번 인증을 받은 사용자가 서비스의 기능을 사용할 때 로그인이 되어있음을 알아보고 허가
- 세션의 허점 : 
    - 서버의 메모리 부족
    - 서버 재부팅 시 모든 접속자 로그아웃
    - 여러 대의 서버 사용 시 문제 발생
        - 데이터베이스 서버 이용 시 속도 저하
        - 메모리형 데이터베이스 서버 사용 시 서버 다운 위험
- 토큰 방식(JWT, JSON Web Token)
    - 로그인 시 사용자에게 토큰 전송
    - 토큰 형태는 XXXXXX.YYYYYY.ZZZZZZ(header(헤더).payload(페이로드).verify signature(서명))
    - Base64로 디코딩 시 JSON 형식으로 정보 들어있음
    - Claim : 토큰에 담긴 사용자 정보등의 데이터
    - header : type과 alg가 담겨있다. type에는 항상 JWT이고 alg는 알고리즘으로 서명값을 만드는데 사용될 알고리즘(암호화 방식) 지정
    - 헤더와 페이로드, 그리고 서버에 감춰놓은 비밀 값. 이 셋을 암호화 알고리즘으로 돌리면 서명값이 나온다.
    - 서버는 요청에 토큰 값이 실려들어오면 헤더와 페이로드을 서버의 비밀 키와 돌려봐서 서명값과 일치하는지 확인
    - 시간에 따라 바뀌는 어떤 상태값을 안 갖는 것 -> stateless
    - JWT의 결점
        - 세션처럼 stateful해서, 모든 사용자들의 상태를 기억하고 있다는 것은 구현하기 부담되고 고려사항도 많지만, 구현만 한다면 기억하는 대상의 상태들을 언제든 제어할 수 있다 -> JWT는 그렇지 않음
        - 서버에 토큰의 정보를 저장해두지 않기 때문에 통제가 힘들다.
        - 토큰이 탈취 당할 경우 토큰을 무효화할 방법이 없다.
    - JWT 보완 방법(여러 방법 중 하나)
        1. 만료시간이 몇시간이나 몇분 이하로 짧은 access 토큰과 꽤 긴, 보통 2주 정도로 잡혀 있는 refresh 토큰, 이 두 개의 토큰을 클라이언트에게 발급
        2. refresh 토큰은 상응값을 데이터베이스에 저장
        3. 클라이언트는 access 토큰의 수명이 다하면 refresh 토큰 서버로 전송
        4. 데이터베이스의 저장된 값과 대조
        5. 일치한다면 새 access 토큰 발급
        
7. 즉시 실행 함수(IIFE)
- Immediately Invoked Function Expression
- (function(){ ... })();으로 실행 가능
- 익명을 해야하냐 기명을 해야하냐의 말이 많다.
- ()로 감싸줌으로서 선언문이 아닌 표현식으로 Parser를 속인다.
- 외부에서 접근할 수 없는 자체 Scope 형성 -> IIFE의 가장 큰 목적
- IIFE에 변수를 할당할 경우, IIFE 자체는 저장되지 않고, IIFE가 실행된 결과만 저장이 된다.
        
8. 정규표현식
- 전방탐색
    - 기호는 ?=이며 = 다음에 오는 문자가 일치하는 영역에서 제외된다.
    - 또한 ()로 감싸주어야한다. -> (?='탐색 기준')
    - 예 : .+(?=k) k 앞의 모든 문자 탐색
- 후방탐색
    - 기호는 ?<=이며 전방탐색과 마찬가지로 = 다음에 오는 문자가 일치하는 영역에서 제외된다.
    - 예 : (?<=k)+. k 뒤의 모든 문자 탐색
- $
    - 끝을 나타내는 기호

## 막혔던 내용 정리
1. GET방식으로 데이터를 보내는 과정 : 
- 현재 게시판 쓰기 API는 GET 방식으로 진행되어 파라미터로 데이터가 전달이 된다. 
- GET방식은 256바이트 이상을 넘길 수 없다고 알려져 있는데 원칙적으로는 제한이 없지만 구형 장비들 중 일부가 256바이트의 주소값을 지원하기 때문에 주의해야한다는 것.
- 약 2000자 정도 이하로 만들어야 모든 브라우저에서 작동
- 한글은 n바이트라는 개념을 통해 한글 한 자를 치기 위해 필요한 타수로 바이트를 계산
- 웹 문서에서 사용되는 다국어 인코딩, 즉 UTF-8 유니코드에서는 한글이나 한자는 3바이트
- URI가 서버가 처리 할 수 있는 거보다 길면 서버는 414 에러를 반환해야한다.
- Lorem Ipsum의 500단어, 3307바이트를 데이터로 넣었을 때 404 에러 발생
- CORS 같은 경우에는 해더값에 Access-Control-Allow-Origin을 추가해 해결이 가능하나, 여전히 길이가 긴 데이터를 보낼 경우 같은 에러가 발생
- lorem ipsum을 통해 다양한 길이의 데이터를 넣어보았고 1484바이트 이상의 데이터 부터는 404 에러를 받는다.
- utf-8의 1글자는 1~4바이트까지 가변적이다.
- 서버의 용량 제한이 있지 않은가 생각 중

2. textarea value를 그대로 저장하게 되면 엔터 처리가 무시된 한줄의 입력값을 받는다.
- '\n'(줄 바꿈) 혹은 '\r\n'(커서를 맨 앞으로 이동시킨 뒤 줄바꿈)인 경우에 br 태그로 처리한다.
    let contentValue = form.notice_write_content.value;
    contentValue = contentValue.replace(/(\n:\r\n)/g, 'br태그')
- br태그가 입력되지만 넘겨지지 않는다.
- innerText로 보여지던 글을 innerHTML로 변경해 해결
